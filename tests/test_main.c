/*
 * DO NOT EDIT THIS FILE. Generated by checkmk.
 * Edit the original source file "tests.check" instead.
 */

#include <check.h>
#include <stdio.h>
#include "../c_read_obj.h"
#include "../c_affins.h"
#include <unistd.h>



//#include "affine.h"

/*
List tests
*/
/*
START_TEST(push_and_pop_list_uint) {
  List *l = init_list();
  ck_assert(is_list_empty(l));
  for (unsigned int i = 1; i <= 10000; i++) {
    Data data = {.index = i};
    push_back_to_list(l, data);
  }
  for (unsigned int i = 1; i <= 10000; i++) {
    ck_assert(!is_list_empty(l));
    Data popped = pop_front_from_list(l);
    ck_assert_uint_eq(popped.index, i);
  }
  ck_assert(is_list_empty(l));
  destroy_list(l);
}
END_TEST

START_TEST(push_and_pop_list_double) {
  List *l = init_list();
  ck_assert(is_list_empty(l));
  for (double i = -100.0; i <= 100.0; i += 0.01) {
    Data data = {.value = i};
    push_back_to_list(l, data);
  }
  for (double i = -100.0; i <= 100.0; i += 0.01) {
    ck_assert(!is_list_empty(l));
    Data popped = pop_front_from_list(l);
    ck_assert_uint_eq(popped.value, i);
  }
  ck_assert(is_list_empty(l));
  destroy_list(l);
}
END_TEST

START_TEST(pop_from_empty_list) {
  List *l = init_list();
  ck_assert(is_list_empty(l));
  Data result = pop_front_from_list(l);
  ck_assert(is_list_empty(l));
  ck_assert_double_eq(result.value, -1);
  destroy_list(l);
}
END_TEST

START_TEST(parse_obj_simple) {
  Obj *obj = parse_obj("./models/simple_cube.obj");
  ck_assert_uint_eq(24, obj->vertexes_count);
  ck_assert_uint_eq(24, obj->f_count);
  ck_assert_uint_eq(24 * 6, obj->faces_count);
  clean_obj(obj);
}
END_TEST

START_TEST(parse_obj_incorrect_vertex) {
  Obj *obj = parse_obj("./models/simple_cube_incorrect_vertex.obj");
  ck_assert(!obj);
  clean_obj(obj);
}
END_TEST

START_TEST(parse_obj_incorrect_face) {
  Obj *obj = parse_obj("./models/simple_cube_incorrect_face.obj");
  ck_assert(!obj);
  clean_obj(obj);
}
END_TEST
*/
START_TEST(affine_transformations_test) {
    /*
  Obj *obj = parse_obj("./models/simple_cube.obj");
  double *new_vertexes = calloc(obj->vertexes_count, sizeof(double));
  translate_model(obj, new_vertexes, 50, 50, -50, 4, 4, 4, 90, 175);

  double *compare_vertexes = calloc(obj->vertexes_count, sizeof(double));
  double cos_x = cos(M_PI * 90 / 180.0), cos_y = cos(M_PI * 175 / 180.0),
         sin_x = sin(M_PI * 90 / 180.0), sin_y = sin(M_PI * 175 / 180.0);
        Ð‘
  for (size_t i = 0; i < obj->vertexes_count; i += 3) {
    compare_vertexes[i] =
        4 * (obj->vertexes[i] * cos_x + obj->vertexes[i + 2] * sin_x) + 50;
    compare_vertexes[i + 1] =
        4 * (obj->vertexes[i + 1] * cos_y + obj->vertexes[i] * sin_x * sin_y -
             obj->vertexes[i + 2] * cos_x * sin_y) +
        50;
    compare_vertexes[i + 2] =
        4 * (obj->vertexes[i + 1] * sin_y - obj->vertexes[i] * sin_x * cos_y +
             obj->vertexes[i + 2] * cos_x * cos_y) +
        -50;

    ck_assert_double_eq(new_vertexes[i], compare_vertexes[i]);
    ck_assert_double_eq(new_vertexes[i + 1], compare_vertexes[i + 1]);
    ck_assert_double_eq(new_vertexes[i + 2], compare_vertexes[i + 2]);
  }
  free(new_vertexes);
  free(compare_vertexes);
  clean_obj(obj);
  */

   ck_assert_double_eq(1, 1);
}
END_TEST


START_TEST(parcing_test) {

    char path_test_obj[256];
    getcwd(path_test_obj, 256);
    strcat(path_test_obj, "/tests/naruto.obj");
    printf("______ %s\n\n\n", path_test_obj);
    struct_data data = {0};
    start_parcer(&data, path_test_obj);
    show_data_stuct(data);
    fflush(stdout);
    ck_assert_double_eq(1, 1);
    clean_data_struct(&data);
END_TEST
}

START_TEST(move_test) {
   matrix_t matrix_test = {0};
   matrix_test.matrix = calloc(3, sizeof(double));
   matrix_test.rows = 1;
   matrix_test.matrix[0] = 1.0;
   matrix_test.matrix[1] = 0.5;
   matrix_test.matrix[2] = -1.0;
   move_x(&matrix_test, 1.0);
   move_y(&matrix_test, 2.0);
   move_z(&matrix_test, 3.0);
    ck_assert_double_eq( matrix_test.matrix[0] , 2);
    ck_assert_double_eq( matrix_test.matrix[1] , 2.5);
    ck_assert_double_eq( matrix_test.matrix[2] , 2);

}
END_TEST


START_TEST(rotate_test) {
        double angle_rad = 0.3;
    matrix_t matrix_test = {0};
    matrix_test.matrix = calloc(3, sizeof(double));
    matrix_test.rows = 1;
    matrix_test.matrix[0] = 1.0;
    matrix_test.matrix[1] = 0.5;
    matrix_test.matrix[2] = -1.0;
    rotation_by_ox(&matrix_test, angle_rad, 0, 0);
    rotation_by_oy(&matrix_test, angle_rad, 0, 0);
    rotation_by_oz(&matrix_test, angle_rad, 0, 0);
  
    fflush(stdout);
    ck_assert_double_eq_tol( matrix_test.matrix[0] , 0.547412, 1e-6);
    ck_assert_double_eq_tol( matrix_test.matrix[1] , 0.359998, 1e-6);
    ck_assert_double_eq_tol( matrix_test.matrix[2] , -1.34935, 1e-5);

}
END_TEST



START_TEST(zoom_test) {

    matrix_t matrix_test = {0};
    matrix_test.matrix = calloc(3, sizeof(double));
    matrix_test.rows = 1;
    matrix_test.matrix[0] = 1.0;
    matrix_test.matrix[1] = 0.5;
    matrix_test.matrix[2] = -1.0;
    zoom(&(matrix_test), 2, 1);
    ck_assert_double_eq_tol( matrix_test.matrix[0] , 2, 1e-6);
    ck_assert_double_eq_tol( matrix_test.matrix[1] , 1, 1e-6);
    ck_assert_double_eq_tol( matrix_test.matrix[2] , -2, 1e-5);

}
END_TEST


int main(void) {
  Suite *s1 = suite_create("Core");
  TCase *tc1_1 = tcase_create("Core");
  SRunner *sr = srunner_create(s1);
  int nf;

  suite_add_tcase(s1, tc1_1);

  tcase_add_test(tc1_1, affine_transformations_test);
  tcase_add_test(tc1_1, parcing_test);
  tcase_add_test(tc1_1, move_test);
  tcase_add_test(tc1_1, rotate_test);
  tcase_add_test(tc1_1, zoom_test);

  srunner_run_all(sr, CK_ENV);
  nf = srunner_ntests_failed(sr);
  srunner_free(sr);

  return nf == 0 ? 0 : 1;
}
